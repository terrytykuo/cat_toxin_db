#!/usr/bin/env python3
"""
import_d1.py — Generate import.sql from data/plants_cleaned/ for Cloudflare D1.

Usage:
  python3 import_d1.py            # generate import.sql
  python3 import_d1.py --stats    # show entity counts only
  python3 import_d1.py --execute  # generate then run via wrangler
"""

import json
import glob
import argparse
import subprocess
from pathlib import Path

CLEANED_DIR = Path("data/plants_cleaned")
OUTPUT_FILE = Path("import.sql")


def escape(val):
    """Escape a string value for SQL."""
    if val is None:
        return "NULL"
    return "'" + str(val).replace("'", "''") + "'"


def normalize_name(name: str) -> str:
    """Normalize entity names: strip whitespace, title case."""
    return name.strip().title()


def load_all() -> list[dict]:
    files = sorted(CLEANED_DIR.glob("*.json"))
    if not files:
        raise FileNotFoundError(f"No files found in {CLEANED_DIR}. Run clean_plants.py first.")
    return [json.loads(f.read_text()) for f in files]


def build_lookup_tables(records: list[dict]) -> tuple[dict, dict, dict, dict]:
    """
    Scan all records and build dedup dicts.
    Returns: (toxic_parts, toxins, symptoms, treatments)
    Each dict maps normalized_name → {id, ...fields}
    """
    toxic_parts = {}   # name → {id}
    toxins      = {}   # name → {id, chemical_formula, description}
    symptoms    = {}   # name → {id, body_system}
    treatments  = {}   # name → {id, description}

    def next_id(d):
        return len(d) + 1

    for record in records:
        for part in record.get("toxic_parts", []):
            if not part:
                continue
            name = normalize_name(part)
            if name not in toxic_parts:
                toxic_parts[name] = {"id": next_id(toxic_parts)}

        for toxin in record.get("toxins", []):
            name = normalize_name(toxin.get("name", "") or "")
            if not name:
                continue
            if name not in toxins:
                toxins[name] = {
                    "id":              next_id(toxins),
                    "chemical_formula": toxin.get("chemical_formula"),
                    "description":     toxin.get("description"),
                }
            else:
                # Merge: fill in nulls from later occurrences
                existing = toxins[name]
                if not existing["chemical_formula"] and toxin.get("chemical_formula"):
                    existing["chemical_formula"] = toxin["chemical_formula"]
                if not existing["description"] and toxin.get("description"):
                    existing["description"] = toxin["description"]

        for symptom in record.get("symptoms", []):
            name = normalize_name(symptom.get("name", "") or "")
            if not name:
                continue
            if name not in symptoms:
                symptoms[name] = {
                    "id":          next_id(symptoms),
                    "body_system": symptom.get("body_system"),
                }

        for treatment in record.get("treatments", []):
            name = normalize_name(treatment.get("name", "") or "")
            if not name:
                continue
            if name not in treatments:
                treatments[name] = {
                    "id":          next_id(treatments),
                    "description": treatment.get("description"),
                }

    return toxic_parts, toxins, symptoms, treatments


def generate_sql(records, toxic_parts, toxins, symptoms, treatments) -> str:
    lines = []
    lines.append("-- Cat Toxin DB — D1 Import")
    lines.append("-- Generated by import_d1.py")
    lines.append("PRAGMA foreign_keys = ON;")
    lines.append("")

    # 1. toxic_parts
    lines.append("-- toxic_parts")
    for name, row in toxic_parts.items():
        lines.append(
            f"INSERT OR IGNORE INTO toxic_parts (id, name) VALUES ({row['id']}, {escape(name)});"
        )
    lines.append("")

    # 2. toxins
    lines.append("-- toxins")
    for name, row in toxins.items():
        lines.append(
            f"INSERT OR IGNORE INTO toxins (id, name, chemical_formula, description) "
            f"VALUES ({row['id']}, {escape(name)}, {escape(row['chemical_formula'])}, {escape(row['description'])});"
        )
    lines.append("")

    # 3. symptoms
    lines.append("-- symptoms")
    for name, row in symptoms.items():
        lines.append(
            f"INSERT OR IGNORE INTO symptoms (id, name, body_system) "
            f"VALUES ({row['id']}, {escape(name)}, {escape(row['body_system'])});"
        )
    lines.append("")

    # 4. treatments
    lines.append("-- treatments")
    for name, row in treatments.items():
        lines.append(
            f"INSERT OR IGNORE INTO treatments (id, name, description) "
            f"VALUES ({row['id']}, {escape(name)}, {escape(row['description'])});"
        )
    lines.append("")

    # 5. plants + junctions
    lines.append("-- plants and junction tables")
    for plant_id, record in enumerate(records, start=1):
        plant = record.get("plant", {})
        basics = record.get("basics", {})
        common  = escape(plant.get("common_name"))
        sci     = escape(plant.get("scientific_name"))
        family  = escape(basics.get("family") or plant.get("family"))
        desc    = escape(basics.get("description") or plant.get("description"))

        lines.append(
            f"INSERT INTO plants (id, common_name, scientific_name, family, description) "
            f"VALUES ({plant_id}, {common}, {sci}, {family}, {desc});"
        )

        # plant_toxic_parts
        for part in record.get("toxic_parts", []):
            if not part:
                continue
            part_name = normalize_name(part)
            part_id = toxic_parts[part_name]["id"]
            lines.append(
                f"INSERT OR IGNORE INTO plant_toxic_parts (plant_id, toxic_part_id) "
                f"VALUES ({plant_id}, {part_id});"
            )

        # plant_toxins
        for toxin in record.get("toxins", []):
            name = normalize_name(toxin.get("name", "") or "")
            if not name or name not in toxins:
                continue
            toxin_id = toxins[name]["id"]
            notes = escape(toxin.get("concentration_notes"))
            lines.append(
                f"INSERT OR IGNORE INTO plant_toxins (plant_id, toxin_id, concentration_notes) "
                f"VALUES ({plant_id}, {toxin_id}, {notes});"
            )

        # plant_symptoms
        VALID_SEVERITY = {"mild", "moderate", "severe", "fatal"}
        for symptom in record.get("symptoms", []):
            name = normalize_name(symptom.get("name", "") or "")
            if not name or name not in symptoms:
                continue
            symptom_id = symptoms[name]["id"]
            severity = symptom.get("severity", "moderate") or "moderate"
            if severity.lower() not in VALID_SEVERITY:
                severity = "moderate"
            onset = escape(symptom.get("onset"))
            notes = escape(symptom.get("notes"))
            lines.append(
                f"INSERT OR IGNORE INTO plant_symptoms (plant_id, symptom_id, severity, onset, notes) "
                f"VALUES ({plant_id}, {symptom_id}, {escape(severity.lower())}, {onset}, {notes});"
            )

        # plant_treatments
        for treatment in record.get("treatments", []):
            name = normalize_name(treatment.get("name", "") or "")
            if not name or name not in treatments:
                continue
            treatment_id = treatments[name]["id"]
            priority = int(treatment.get("priority") or 0)
            notes = escape(treatment.get("notes"))
            lines.append(
                f"INSERT OR IGNORE INTO plant_treatments (plant_id, treatment_id, priority, notes) "
                f"VALUES ({plant_id}, {treatment_id}, {priority}, {notes});"
            )

        lines.append("")

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--stats",   action="store_true", help="Show counts only")
    parser.add_argument("--execute", action="store_true", help="Run via wrangler after generating")
    args = parser.parse_args()

    print("Loading cleaned plant data...")
    records = load_all()
    print(f"  {len(records)} plants loaded")

    print("Building lookup tables...")
    toxic_parts, toxins, symptoms, treatments = build_lookup_tables(records)

    print(f"  toxic_parts : {len(toxic_parts)}")
    print(f"  toxins      : {len(toxins)}")
    print(f"  symptoms    : {len(symptoms)}")
    print(f"  treatments  : {len(treatments)}")

    if args.stats:
        return

    print("Generating SQL...")
    sql = generate_sql(records, toxic_parts, toxins, symptoms, treatments)
    OUTPUT_FILE.write_text(sql)
    print(f"  Written to {OUTPUT_FILE} ({OUTPUT_FILE.stat().st_size:,} bytes)")

    if args.execute:
        print("Running: wrangler d1 execute cat-toxin-db --file=import.sql --remote")
        result = subprocess.run(
            ["wrangler", "d1", "execute", "cat-toxin-db", "--file=import.sql", "--remote"],
            capture_output=True, text=True
        )
        print(result.stdout)
        if result.returncode != 0:
            print("ERROR:", result.stderr)


if __name__ == "__main__":
    main()
